#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
gpt5: WSL向け GPT-5 CLI
- Web検索統合（tools:web_search）
- 履歴保存（擬似スレッド）
- スレッド一覧/履歴表示
- 追加: エクスポート(--export markdown/json), grep(--grep)
- 追加: デフォルトスレッド(--set-default/--get-default)
- 追加: ファイルアップロード(--upload)と既存ファイル添付(--attach)
"""

import argparse, json, os, sys, time, glob, datetime, re
import requests
from pathlib import Path

API_URL = "https://api.openai.com/v1/responses"
FILES_URL = "https://api.openai.com/v1/files"
MODEL   = "gpt-5"   # gpt-5 / gpt-5-mini など
BASE_DIR = os.path.expanduser("~/.gpt5_cli")
CONFIG   = Path(BASE_DIR) / "config.json"

# ---------- util: config ----------
def _ensure_dir():
    Path(BASE_DIR).mkdir(parents=True, exist_ok=True)

def get_default_session():
    _ensure_dir()
    if CONFIG.exists():
        try:
            cfg = json.loads(CONFIG.read_text(encoding="utf-8"))
            return cfg.get("default_session", "default")
        except Exception:
            return "default"
    return "default"

def set_default_session(name: str):
    _ensure_dir()
    cfg = {}
    if CONFIG.exists():
        try:
            cfg = json.loads(CONFIG.read_text(encoding="utf-8"))
        except Exception:
            cfg = {}
    cfg["default_session"] = name
    CONFIG.write_text(json.dumps(cfg, ensure_ascii=False, indent=2), encoding="utf-8")

# ---------- util: history ----------
def hist_path(session: str) -> Path:
    return Path(BASE_DIR) / f"{session}.json"

def load_history(session: str):
    p = hist_path(session)
    if not p.exists(): return []
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        return []

def save_history(session: str, history):
    _ensure_dir()
    hist_path(session).write_text(json.dumps(history, ensure_ascii=False, indent=2), encoding="utf-8")

def list_sessions():
    _ensure_dir()
    rows = []
    for fp in sorted(glob.glob(str(Path(BASE_DIR) / "*.json"))):
        session = Path(fp).stem
        try:
            hist = json.loads(Path(fp).read_text(encoding="utf-8"))
            n = len(hist)
        except Exception:
            n = -1
        mtime = datetime.datetime.fromtimestamp(os.path.getmtime(fp))
        rows.append((session, n, mtime))
    return rows

def print_sessions(rows, default_name):
    if not rows:
        print("(スレッドがありません) まずは質問して履歴を作成してください。")
        return
    print("セッション名\tメッセージ数\t最終更新\t(★=デフォルト)")
    for s, n, mt in rows:
        star = "★" if s == default_name else ""
        print(f"{s}\t{n}\t{mt.strftime('%Y-%m-%d %H:%M:%S')}\t{star}")

# ---------- export ----------
def to_markdown(history, session):
    lines = [f"# Session: {session}", ""]
    for m in history:
        role = m.get("role","?")
        ts = m.get("ts")
        if ts:
            dt = datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S")
            header = f"## {role} @ {dt}"
        else:
            header = f"## {role}"
        content = m.get("content","")
        if isinstance(content, list):  # {type:"text", text:"..."} の配列を想定
            content = "".join(x.get("text","") for x in content if isinstance(x, dict))
        lines.append(header)
        lines.append("")
        lines.append(content if isinstance(content, str) else json.dumps(content, ensure_ascii=False))
        # 添付メタ表示
        if m.get("files"):
            lines.append("")
            lines.append(f"> attached files: {', '.join(m['files'])}")
        lines.append("")
    return "\n".join(lines).strip() + "\n"

def export_history(session, fmt, out_path=None, role="all", last=None):
    hist = load_history(session)
    if role in ("user","assistant"):
        hist = [m for m in hist if m.get("role")==role]
    if last and last>0:
        hist = hist[-last:]
    if fmt == "markdown":
        data = to_markdown(hist, session)
    elif fmt == "json":
        data = json.dumps(hist, ensure_ascii=False, indent=2)
    else:
        raise ValueError("unsupported export format")
    if out_path:
        Path(out_path).write_text(data, encoding="utf-8")
        print(f"exported -> {out_path}")
    else:
        print(data)

# ---------- grep ----------
def grep_sessions(pattern, session=None, all_sessions=False, role="all", ignore_case=False, last=None):
    flags = re.IGNORECASE if ignore_case else 0
    prog = re.compile(pattern, flags)
    targets = []
    if all_sessions:
        targets = [s for s,_,_ in list_sessions()]
    else:
        targets = [session or get_default_session()]
    hits = []
    for s in targets:
        hist = load_history(s)
        if role in ("user","assistant"):
            hist = [m for m in hist if m.get("role")==role]
        if last and last>0:
            hist = hist[-last:]
        for idx, m in enumerate(hist, 1):
            c = m.get("content","")
            if isinstance(c, list):
                c = "".join(x.get("text","") for x in c if isinstance(x, dict))
            if not isinstance(c, str):
                c = json.dumps(c, ensure_ascii=False)
            if prog.search(c):
                ts = m.get("ts")
                stamp = datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S") if ts else "-"
                hits.append((s, idx, m.get("role","?"), stamp, c))
    return hits

def print_grep_results(hits):
    if not hits:
        print("(一致なし)")
        return
    for (sess, idx, role, ts, text) in hits:
        print(f"[{sess}] #{idx} {role} @ {ts}\n{text}\n")

# ---------- files API ----------
def upload_files(paths, api_key, purpose="responses"):
    """複数パスを /v1/files にアップロードし、file_id の配列を返す"""
    ids = []
    headers = {"Authorization": f"Bearer {api_key}"}
    for path in paths:
        p = Path(path)
        if not p.exists():
            print(f"[warn] file not found: {path}", file=sys.stderr)
            continue
        with open(p, "rb") as f:
            files = {
                "file": (p.name, f),
                "purpose": (None, purpose),
            }
            r = requests.post(
                FILES_URL,
                headers=headers,
                data={"purpose": purpose},      # ← フォームフィールド
                files={"file": (p.name, f)},    # ← バイナリ
                timeout=600
            )
            if r.status_code != 200:
                print(f"[error] upload failed: {p} -> {r.status_code} {r.text}", file=sys.stderr)
                continue
            j = r.json()
            fid = j.get("id")
            if fid:
                ids.append(fid)
                print(f"[uploaded] {p} -> {fid}")
            else:
                print(f"[warn] no id in response for {p}", file=sys.stderr)
    return ids

# ---------- API ----------
def build_user_content(prompt, file_ids):
    """content（ユーザー発話）を、ファイル添付の有無で作り分け"""
    if file_ids:
        content = [{"type":"input_text","text": prompt}]
        for fid in file_ids:
            content.append({"type":"input_file","file_id": fid})
        return content  # list
    else:
        return prompt    # str

def _to_api_message(m):
    role = m.get("role", "user")
    content = m.get("content", "")
    # content は str か、[{type:"text",text:"..."}, {type:"input_file",file_id:"..."}] のいずれか
    # 保存用に付けた files/ts などは送らない
    return {"role": role, "content": content}

def sanitize_history_for_api(history):
    api_msgs = []
    for m in history:
        api_msgs.append(_to_api_message(m))
    return api_msgs

def make_payload(history, prompt, use_search=True, file_ids=None):
    # 履歴はサニタイズして送る
    msgs = sanitize_history_for_api(history)

    # 今回のユーザー発話（添付ありなら input_file を並べる）
    content = [{"type":"input_text","text": prompt}] if prompt else []
    for fid in (file_ids or []):
        content.append({"type":"input_file","file_id": fid})
    if not content:
        content = ""  # 本当に空なら空文字（ただし通常は何かテキストを推奨）

    msgs.append({"role": "user", "content": content})

    payload = {"model": MODEL, "input": msgs}
    if use_search:
        payload["tools"] = [{"type":"web_search"}]
    return payload

def call_api(payload, api_key):
    headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
    resp = requests.post(API_URL, headers=headers, data=json.dumps(payload), timeout=600)
    if resp.status_code != 200:
        raise RuntimeError(f"API error {resp.status_code}: {resp.text}")
    return resp.json()

def extract_text(resp_json):
    if resp_json.get("output_text"):
        return resp_json["output_text"]
    items = resp_json.get("output", []) or resp_json.get("response", {}).get("output", [])
    chunks = []
    for it in items:
        if it.get("type") == "message":
            for c in it.get("content", []):
                if c.get("type") in ("output_text","text") and "text" in c:
                    chunks.append(c["text"])
    if chunks:
        return "".join(chunks)
    choices = resp_json.get("choices")
    if isinstance(choices, list) and choices:
        msg = choices[0].get("message", {})
        cont = msg.get("content")
        if isinstance(cont, str): return cont
        if isinstance(cont, list):
            return "".join(x.get("text","") for x in cont if isinstance(x, dict))
    return ""

# ---------- main ----------
def main():
    ap = argparse.ArgumentParser(description="GPT-5 CLI (history, web_search, list/show/export/grep, default session, file upload)")
    # 通常質問
    ap.add_argument("prompt", nargs="*", help="質問/指示。未指定なら標準入力から")
    ap.add_argument("--session", "-s", help="履歴ファイル名（スレッド名）。未指定時はデフォルトセッションを使用")
    ap.add_argument("--no-search", action="store_true", help="Web検索を無効化")

    # 一覧/表示
    ap.add_argument("--list", action="store_true", help="スレッド一覧を表示", default=False)
    ap.add_argument("--show", action="store_true", help="このセッション（またはデフォルト）の履歴を表示")
    ap.add_argument("--last", type=int, help="--show/--export/--grep時: 末尾N件だけ")
    ap.add_argument("--role", choices=["all","user","assistant"], default="all", help="--show/--export/--grepのロール絞り込み")

    # エクスポート
    ap.add_argument("--export", choices=["markdown","json"], help="履歴を指定フォーマットで出力")
    ap.add_argument("--out", help="--export時の出力先ファイル。未指定なら標準出力")

    # grep
    ap.add_argument("--grep", help="履歴内を正規表現で検索")
    ap.add_argument("--all", action="store_true", help="--grep時: 全スレッド横断で検索")
    ap.add_argument("--ignore-case", "-i", action="store_true", help="--grep時: 大文字小文字を無視")

    # デフォルトスレッド
    ap.add_argument("--set-default", metavar="SESSION", help="デフォルトセッションを設定")
    ap.add_argument("--get-default", action="store_true", help="現在のデフォルトセッションを表示")

    # ファイルアップロード/添付
    ap.add_argument("--upload", nargs="+", help="ローカルファイルを /v1/files にアップロードして添付")
    ap.add_argument("--attach", nargs="+", help="既存の file_id を直接添付（スペース区切りで複数可）")

    args = ap.parse_args()

    # デフォルト関連
    if args.get_default:
        print(get_default_session()); return
    if args.set_default:
        set_default_session(args.set_default)
        print(f"default session -> {args.set_default}")
        return

    # 一覧
    if args.list:
        print_sessions(list_sessions(), get_default_session())
        return

    # ターゲットセッションを決定
    session = args.session or get_default_session()

    # 表示
    if args.show and not args.export and not args.grep:
        hist = load_history(session)
        if args.role in ("user","assistant"):
            hist = [m for m in hist if m.get("role")==args.role]
        if args.last and args.last>0:
            hist = hist[-args.last:]
        if not hist:
            print(f"(セッション '{session}' の履歴はありません)")
            return
        for i, m in enumerate(hist, 1):
            r = m.get("role","?")
            c = m.get("content","")
            if isinstance(c, list):
                c = "".join(x.get("text","") for x in c if isinstance(x, dict))
            print(f"[{i}] {r}:\n{c}")
            if m.get("files"):
                print(f"(attached: {', '.join(m['files'])})")
            print()
        return

    # エクスポート
    if args.export:
        export_history(session, args.export, out_path=args.out, role=args.role, last=args.last)
        return

    # grep
    if args.grep:
        hits = grep_sessions(args.grep, session=session, all_sessions=args.all,
                             role=args.role, ignore_case=args.ignore_case, last=args.last)
        print_grep_results(hits)
        return

    # ---- 通常問い合わせ ----
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        print("ERROR: OPENAI_API_KEY が未設定です。export OPENAI_API_KEY=... を実行してください。", file=sys.stderr)
        sys.exit(1)

    # 入力取得
    if args.prompt:
        prompt = " ".join(args.prompt)
    else:
        prompt = sys.stdin.read().strip()
    if not prompt and not args.upload and not args.attach:
        print("空のプロンプトです（ファイルだけ投げる場合は何かしらの指示文も推奨）", file=sys.stderr); sys.exit(1)

    # アップロード → file_id
    file_ids = []
    if args.upload:
        file_ids.extend(upload_files(args.upload, api_key, purpose="user_data"))
    if args.attach:
        file_ids.extend(args.attach)

    history = load_history(session)
    payload = make_payload(history, prompt or "ファイルを解析してください。", use_search=(not args.no_search), file_ids=file_ids)
    resp = call_api(payload, api_key)
    text = extract_text(resp) or "(no text)"

    print(text.strip())

    now_ts = int(time.time())
    # 履歴に、添付ファイルIDもメタとして保存
    history.append({"role": "user", "content": (prompt or ""), "files": file_ids, "ts": now_ts})
    history.append({"role": "assistant", "content": text, "ts": now_ts})
    save_history(session, history)

if __name__ == "__main__":
    # シェバンより前の空行NG / 改行はLF
    main()
